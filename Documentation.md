# Документация по использованию приложения для генерации лабиринтов
## Введение
Это приложение предназначено для генерации и поиска пути в лабиринтах. Оно предлагает пользователю выбрать алгоритмы для построения лабиринта и поиска пути, а также настроить размеры лабиринта и выбрать стартовую и целевую точки.
## Использование
При запуске приложения вам будет предложено выполнить следующие действия:

### 1. Выбор алгоритма генерации лабиринта
* Приложение отобразит список доступных алгоритмов для построения лабиринта.
* Введите номер алгоритма, который вы хотите использовать.

### 2. Установка размеров лабиринта
* Вам будет предложено ввести высоту лабиринта.
* Введите значение в диапазоне от 5 до 47.
* Затем вам будет предложено ввести ширину лабиринта с теми же ограничениями.

### 3. Просмотр сгенерированного лабиринта
* После установки размеров лабиринта приложение сгенерирует лабиринт и отобразит его в консоли.

### 4. Выбор точки начала и целевой точки
* Вам будет предложено выбрать точку начала и целевую точку построения пути (например, справа сверху).
* Введите номер, соответствующий желаемой точке.

### 5. Выбор алгоритма поиска пути
* Вам будет предложено выбрать алгоритм поиска пути, который вы хотите использовать для нахождения пути от стартовой точки к целевой.
* Введите номер алгоритма.

### 6. Просмотр пути
* После выполнения всех шагов приложение выполнит поиск пути и отобразит его в сгенерированном лабиринте.
* В случае невозможности построения пути между двумя точками, алгоритм выведет "Путь не найден!"


________________________________________________________________________________________________________________________


## Алгоритмы построения лабиринта

### Рандомизированный алгоритм Прима
1. Начните с сетки, полной стен.
2. Выберите ячейку, отметьте её как часть лабиринта. Добавьте стены ячейки в список стен.
3. Пока в списке есть стены:

    1. Выберите случайную стену из списка. Если посещается только одна из ячеек, которые разделяет стена, то:
       1. Сделайте из стены проход и отметьте непосещённую клетку как часть лабиринта.
       2. Добавьте соседние стены ячейки в список стен.
    2. Удалите стену из списка.
   

### Рекурсивный поиск назад
Представляет собой рандомизированную версию алгоритма поиска в глубину. Алгоритм принимает на вход четные и нечетные размеры лабиринта, но в процессе выполнения приводит к нечетным значениям(приводя в большую сторону).

1. Выберите начальную ячейку, пометьте ее как посещенную и поместите в стек
2. Пока стек не пуст

    1. Извлеките ячейку из стека и сделайте ее текущей ячейкой
    2. Если в текущей ячейке есть какие-либо соседи, которые не были посещены
       1. Помещаем текущую ячейку в стек
       2. Выберите одного из непрошеных соседей
       3. Удалите перегородку между текущей ячейкой и выбранной ячейкой
       4. Отметьте выбранную ячейку как посещенную и поместите ее в стек
    

## Алгоритмы поиска пути
### А*
A* (A-star) — это алгоритм поиска, который используется для нахождения кратчайшего пути в графах. Он сочетает в себе особенности алгоритмов поиска в глубину и поиска в ширину, при этом использует эвристическую функцию для оценки стоимости пути. A* обеспечивает более эффективный поиск, чем BFS или DFS, за счет оценки расстояния до целиВ лабиринте можно двигаться в четырёх направлениях (влево, вправо, вверх и вниз). Двигаться по стенам запрещено, различные типы поверхности улучшают или ухудшают проходимость.
Алгоритм поддерживает разные поверхности и строит кратчайший путь в зависимости от поверхности.
Каждый раз при посещении узла подсчитывается его стоимость f(n) (за n принимается соседний узел). Таким образом, алгоритм посещает все соседние узлы и высчитывает тот, у которого данный показатель минимален.

Формула выглядит следующим образом:
f(n) = g(n) + h(n)

1. #### Инициализация:
* Создать очередь для хранения узлов, отсортировать по f(n).
2. #### Добавление начального узла:
* Поместить стартовый узел в очередь.
3. #### Цикл обхода:
* Пока очередь не пуста:
  * Извлечь узел
  * Если цель - восстановить путь
  * Получить соседей
    * Для каждого соседа
      * Если не стена - считаем g
      * Если новая стоимость меньше текущей, обновить значения и добавить соседа в очередь.
4. #### Завершение:
* Если цель не найден и очередь пуста, вернуть пустой список.


### BFS поиск в ширину

Поиск в ширину (Breadth-First Search, BFS) — это алгоритм для обхода или поиска в графах или деревьях. Он исследует все соседние узлы текущего уровня, прежде чем переходить к узлам следующего уровня. 
Алгоритм не учитывает разные типы поверхности, кроме прохода и стены.

1. #### Инициализация:
* Создать очередь для хранения узлов, которые нужно исследовать
* Создать мапу для отслеживания посещённых узлов и их предков, что позволяет восстанавливать путь.
2. #### Добавление начального узла:
* Поместить стартовый узел в очередь и отметьте его как посещённый.
3. #### Цикл обхода:
* Пока очередь не пуста, извлечь узел из очереди (это будет текущий узел).
* Если текущий узел - цель, восстановить путь от начального узла до целевого, используя информацию о предках.
* Иначе, получить всех его соседей
* Для каждого соседа:
    * Проверить, не является ли он стеной и не был ли он посещён ранее.
    * Если сосед допустимый, создать новый узел, связывая его с текущим, добавить его в очередь и отметьте как посещённый.
4. #### Завершение:
* Если очередь пуста, и целевой узел не был найден, возвращается пустой список, что означает, что путь не существует.
